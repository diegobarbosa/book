
# Static indexes

In the previous chapter, we talked about dynamic indexes and the query optimizer. For the most part, those serve very well to free you from the need to manually deal with indexing. Pretty much all of the standard queries can be safely handed over to the query optimizer and it will take care of that.

That leave us to deal with all of the non standard queries. Those can be full text search, spatial queries, querying on dynamic fields or any real complexity. That isn't to say that defining static indexes in RavenDB is complex, only that they are required when the query optimizer can't really guess what you wanted.

By the end of this chapter, you'll know how to create static index in the stuido and in your code, how to version them in your source control system and how to make RavenDB sit down, beg and (most importantly) go and fetch the right documents for you.

## Creating & managing indexes

We'll start with the simplest possible index, just finding companies by their country. Go to the Northwind database in the Studio, and then to the indexes tab, create a new index, name it "Companies/ByCountry" and then fill the map field with the following index definition:

 	from company in docs.Companies
	select new { Country = company.Address.Country }

You can now save the index. RavenDB will now run all the documents in the `Companies` collection and push them through the index defintion. For the `companies/1` document, the output of this index would be a single field `Country`, which has the value 'Germany'. We have gone on exactly how this work in the previous chapters. 

This kind of index isn't really useful, of course. We are usually better off letting the query optimizer handle such simple indexes, rather than write such trivial indexes ourselves.
We demonstrate with such an index because it allows us to talk about the mechanics of working with indexes without going into any extra details.

With RavenDB, you don't have to define a schema, but in many cases, your code will expect certain indexes to be available. How do you manage your indexes? 

One way of doing that is to do so manually. You can either export just the index defintions from the development server and import them to the production server. Another would be to use the copy/paste index defintion from one server to the next. Or you can just jot it down on using pen & paper and remember to push those changes to production.

Of course, all those options have various issues, not the least of which is that they are manual processes, and that they don't tie down to your code and the version that it is expecting. This is a common problem in any schema management system. You have to take special steps to make sure that everything is in sycn, and you need to version and control your changes explicitly.

That is the cause for quite a lot of pain. When giving talks, I used to ask people how many of them ever managed to get a failed deployment because they forgot to run the schema changes. And I got a _lot_ of hands raising, every single time. With RavenDB, we didn't want to have the same issues. That is why we have the option of managing indexes in your code.

## Defining indexes in your code

So far, we worked with indexes only inside the studio. That is a great way to work with them, but it doesn't allow us to _manage_ them properly. Most importantly, it is possible for indexes to go out of tune with our codebase. That is why RavenDB allows to define indexes in code. Listing 8.1 shows the same index as before, but now defined as C# code inside our solution.


```{caption="{Defining index in code}" .cs}
public class Companies_ByCountry : AbstractIndexCreationTask<Company>
{
	public Companies_ByCountry()
	{
		Map = companies =>
			from company in companies
			select new { company.Address.Country };
	}
}
```

There are a few things to note about Listing 8.1. 

* The class name is `Companies_ByCountry`, by convention, we'll turn that into an index named `Companies/ByCountry` (since we can't use slash as a C# class name).
* The class inherits from AbstractIndexCreationTask<Company>, which marks this class as an index that operates on the `Companies` collection.
* The value of the `Map` property is the actual index defintion that will be sent to the server.

Note that this is _just_ the index defintion. Having this in your code doesn't do anything. In order to actually create the index, you need to execute it, like so:

	new Companies_ByCountry().Execute(documentStore);

This will create the index on the server. But you don't want to have to remember this for each and every index that you have. A far more common way to handle this is to ask RavenDB to just handle it all for you:

	var asm = typeof (Companies_ByCountry).Assembly;
	IndexCreation.CreateIndexes(asm, documentStore);

Usually, this is done as part of initializing the document store, so all the indexes in the assemblies will be picked up and created automatically. This frees you from having to deal with manually managing the indexes. If you create or modify an index, it will create the index on the server automatically. During development, this is the prefered mode for working. Yoy modify the index, hit F5, and the index is updated on the server side. If the server side index definition matches the index definition on the client, the operation has no effect. 

The indexes are defined in your code, so they are versioned and deployed with your code. That relieves you from handling index updates manually. This dramatically reduce the amount of effort and pain that you have to go through for deployments.

> **Locking indexes**
>
> Sometimes you need to make a change to your index definition on your live server. That is possible, of course, but you have to be aware that 
> if you are using `IndexCreation` to automatically generate your indexes, the next time your application will start, it will reset the index definition.
> 
> That can be somewhat annoying, because changing the index definition on the live server can be a hotfix to solve a problem or introduce a new behavior, 
> and the index rest will just make it go away, apparantely randomly.
> 
> In order to handle this, RavenDB allows the option of locking an index. An index can be unlocked, locked (ignore) and locked (error). In the unlocked 
> mode, any change to the index would be accepted and if the new index defintion is different than the one stored on the server, the index would be updated.
> 
> In the locked (ignored) mode, a new index defintion would appear to complete successfully, but will not actually change anything on the server. And in 
> the locked (error) mode, trying to change the index will raise an error.
>
> Usually you'll just mark the index as locked (ignore), which will make the server ignore any changes to the index. The idea is that we don't want to 
> your calls to `IndexCreation` by throwing an error.
>
> Note that this is _not_ a security measure, it is a way for the operation team to make a change in the index and prevent the application from mindlessly setting it back.

Now that we know how to work with indexes in our code, we need to upgrade from writing trivial index to writing _useful_ stuff.

## Complex queries and doing great things with indexes

RavenDB doesn't allow any computation during the query. This is done to ensure that all queries in RavenDB can be easily translated into an operation on an index. That, in turn, means that all the queries in RavenDB have very high efficency. Let us look at what looks like a simple example. 
In the Northwind database, I want to find all of the big orders, sorted by date. A big order is an order for more than $10,000. 

Using SQL, here is how I can express such a query:

	SELECT * FROM Orders o
	WHERE (
	  SELECT  
	    SUM((UnitPrice *  Quantity) * (1 - Discount)) 
	  FROM [Order Details] AS od
	  WHERE o.OrderID = od.OrderID
	) > 10000

Let us consider the amount of work that the database engine has to do to process such a query. First, it has to scan all the rows in the Orders table, and then sum up all the order details for each order. Only after it has the full information for each order, can the database engine decide whatever it needs to output the row or discard it. On small data sets, that works pretty well. On larger data sets... well, that isn't really going to work. 

With RavenDB, we can try running the following query:

	session.Query<Order>()
		.Where(x => x.Lines
				.Sum(l => l.Discount*l.PricePerUnit*(1 - l.Discount)) > 10000)
		.ToList();

This looks pretty good, right? But trying to run this would result in an error saying that the linq provider can't understand how to translate it, or that it is not possible to perform computation during queries.
That seems to be a pretty harsh limitation, doesn't it? How can we solve the problem of finding the expensive orders?

While we cannot execute computations during query, we are absolutely able to run them _during indexing_. Let us look at Listing 8.2, to see just such an index.

```{caption="{Computation during indexing}" .cs}
public class Orders_Totals : 
	AbstractIndexCreationTask<Order, Orders_Totals.Result>
{
	public class Result
	{
		public double Total; 
	}

	public Orders_Totals()
	{
		Map = orders =>
			from order in orders
			select new
			{
				Total = order.Lines.Sum(l => 
					(l.Quantity * l.PricePerUnit) * (1 - l.Discount))
			};
	}
}
```

The index in Listing 8.2 can then be queried using the code in Listing 8.3.

```{caption="{Querying on a computed index field}" .cs}
session.Query<Orders_Totals.Result, Orders_Totals>()
	.Where(x => x.Total > 10000)
	.OfType<Order>()
	.ToList();
```
What would the query in Listing 8.3 do? Instead of having to force the database engine to run through all of the orders, the index definition already computed the total during the indexing. That means that we only have to do a seek through the index to find the relevant orders, which would be very fast.

By moving all computation from query time (expensive, often require to run through the entire data set on every query) to indexing time (cheap, happen only when a document changes), we are able to change the costs associated with queries. Even complex queries always end up being some sort of a search on the index. That is one of the reasons why we usually don't have to deal with slow queries in RavenDB. There isn't anything that would cause them to be slow.

### The many models of indexing

In Listing 8.3, we have seen how we can query an index that uses a computation. That syntax is quite strange, because there seems to be a _lot_ of types being bandied about. This is because there are mutliple models that are being used here, and in this case, they are all different. 

Indexing and querying in RavenDB is done using the following models:

* The documents to be indexed.
* The index entry is the output from the indexing function.
* The query model is how we can query on the index.
* The query result is what is actually returned from the index.

This is a bit confusing, but it can be quite powerful. Let us see _why_ we have so many models, first.

The difference between documents and index entries is obvious. We can see the difference quite clearly in Listing 8.2. The document doesn't have a Total field, and the index is computing that value and output that field to the index. Thus, the index entry for `orders/1` has a Total field with a value of 440. 

Because we have this difference between the document that was indexed and the actual index entry, we also have a difference between how we query and what is actually returned. Look at Listing 8.3. We start the query using: `Query<Orders_Totals.Result, Orders_Totals>()`. 

The first generic parameter `Orders_Totals.Result` is the query model, and the second is the index to use. The query model is usually also the query result, since most times this is the same thing. In this case, however, we need to query on the `Total` field, which does not exist on the document. 

As we discussed in [Chapter 6](#how-indexing-works-in-ravendb), the way queries work in RavenDB is that we first run the query against the index, which gives us the match index entries. We then take the `__document_id` property from each of those matching index entries and use that to load the relevant documents from the document store. 

This is exactly what is going on in Listing 8.3. We start by using the query model `Orders_Totals.Result`, but what we are actually getting back from the server is the list of matching _orders_. Because of that, we need to explicitly change the type that the Linq query will use. We do that using the `OfType<Order>` method.

Note that the `OfType<Order>` method is actually purely for the client side. This is required solely so that the client can understand what type it is going to get. It has no impact on the server. 

To make things more interesting, the index entry and the query model aren't one and the same. Let us look at Listing 8.4 for one such example.

```{caption="{Index using different index entry and query models}" .cs}
public class Orders_Products :
	 AbstractIndexCreationTask<Order, Orders_Products.Result>
{
	public class Result
	{
		public string Product;
	}

	public Orders_Products()
	{
		Map = orders =>
			from order in orders
			select new
			{
				Product = order.Lines.Select(x => x.Product).ToArray()
			};
	}
}
```

As you can see, there is a (small) difference between the output of the index defintion (`Product` is an array of strings) and the shape of the index result (`Product` is just a string). The reason for the difference between the model relates to how we can query them. When RavenDB encounters a collection in the index entry fields, it is actually indexing that field mulitple times. 

If we look at `orders/1` document, the output of the index in Listing 8.4 would be:

	Product: ["products/11", "products/42", "products/72"]

However, when we want to query, we don't treat this as a collection. Instead, we treat it as a single field that has multiple values. In other words, the following query will give me all the orders for `products/11`:

	session.Query<Orders_Products.Result, Orders_Products>()
		.Where(x=>x.Product == "products/11")
		.OfType<Order>()
		.ToList();

We aren't treating this as a collection, but just as a simple value. This seems silly. Why go into all this trouble and introduce a whole new model when we could have just called `Contains()` and call it a day? 

This behavior can be very helpful when you have a more complex index, such as Listing 8.5.

```{caption="{Index for searching employees by name or territory}" .cs}
public class Employees_Search : 
	AbstractIndexCreationTask<Employee, Employees_Search.Result>
{
	public class Result
	{
		public string Query;
	}

	public Employees_Search()
	{
		Map = employees =>
			from employee in employees
			select new
			{
				Query = new object[]
				{
					employee.FirstName,
					employee.LastName,
					employee.Territories
				}
			};
	}
}
```

In Listing 8.5, the output of the index for `employees/1` would be:

	Query: ["Davolio", "Nancy", ["06897", "19713"]]

Note that we don't have a simple array, but an array that contain strings and and an array of strings. We can't just call `Contains()` on the Query field. But because RavenDB will flatten out collections, we can query this index using the following code, and we'll get the `employees/1` document:

	session.Query<Employees_Search.Result, Employees_Search>()
		.Where(x=>x.Query == "06897")
		.OfType<Employee>()
		.ToList();

This ability can be _extremely_ useful whenever we want to use an index for searching. We'll cover this in a lot more on the [next chapter](#complete-search-example).

Having so many models can be confusing, but usually all of them are the same model, so you can pretty much ignore this behavior. It is only when we start getting to interesting stuff that you'll find that this is becoming really interesting. 

We'll see a lot more interesting ways to play with the shape of the data that goes into the index entries later on in this chapter. For now, I want to talk about the importance of chastity. Um... nope, not that. What was that term... oh, yes! Purity!

### The purity of indexes

You can do quite a lot in the index, computing the total for an order is a very simple thing. However, RavenDB 
indexes _require_ that the indexing function will be pure. What does this mean?

A pure function always evaluates the same result value given the same argument value(s), and has no observable 
side effects. The indexing function in Listing 8.2 is pure. Given the same input, it will always generate the 
same output, and it doesn't modify anything else. 

A good example of an a function that isn't pure is one that is using DateTime.Now. Because running it multiple 
times will generate a different value, depending on what the current time is, the function isn't pure. In 
theory, there isn't really a big issue about such an index. We can certainly make it work

The problem is what it _means_. A lot of the time, when users have used DateTime.Now in an index, it was related
to age. I want an index for the users who logged in during the last hour. And the index was:

	from user in docs.Users
	where (DateTime.Now - user.LastLogin).TotalHours < 1
	select new { user.Id, user.Name }

The problem with such an index is that it _looks_ okay, but what it actually does is different from what the 
user expected. This only counted the users who logged in within an hour of _being indexed_. After the document
has been indexed, there was no need to reindex them, so they remained in the index, and caused quite a bit of 
confusion. 

Because of that, using DateTime.Now or any equivalent function is blocked in RavenDB. A much better index would be:

	from user in docs.Users
	select new { user.Id, user.Name, user.LastLogin }

Which we can then query for all the users whose last login is greater than an hour ago. This also gives us the flexibility to check users that logged in a day ago, or just fifteen minutes ago, etc.

So far, we looked at simple indexes. An index that have only a single map function in the index definition, and is operating on a single collection. But RavenDB actually allows us to do much more, using multi map indexes.

## Multi map indexes

Usually an index has a single map function, and it is going to operate on a single collection. And for the most part, that is a great thing to have. But there is more that we can do with RavenDB. Multi map indexes allows us to define more than a single map function (as you probably expected from the name).

But why would we want to ever do something like that? Using the Northwind database, we need to search for a particular person. In this database, a person can be an employee, a company's contact or a supplier's contact. I don't care about that, all I care about is to find that guy, Michael. How can we do that in RavenDB? Let us take a look at Listing 8.6.

```{caption="{Multi map index for searching on employees or companies and supplies' contacts}" .cs}
public class People_Search : 
	AbstractMultiMapIndexCreationTask
{
	public People_Search()
	{
		AddMap<Company>(companies =>
			from company in companies
			select new
			{
				company.Contact.Name,
			});

		AddMap<Employee>(employees =>
			from employee in employees
			select new
			{
				Name = employee.FirstName + " " + employee.LastName
			});

		AddMap<Supplier>(suppliers =>
			from supplier in suppliers
			select new
			{
				supplier.Contact.Name
			});

		Index("Name", FieldIndexing.Analyzed);
	}

}
```

What do we have in Listing 8.6? We have an index definition on the client side, but unlike the previous indexes, this one is inheriting from `AbstractMultiMapIndexCreationTask`, instead of `AbstractIndexCreationTask`. There is really no real difference between the two except that `AbstractMultiMapIndexCreationTask` allows you to specify multiple maps using the `AddMap` method, vs. the single `Map` property in `AbstractIndexCreationTask`^[You can use `AbstractMultiMapIndexCreationTask` to create indexes with a single map.].

Unlike `AbstractIndexCreationTask`, we don't specify the source for the map in the class generic parameter. Instead, we use the generic parameter for `AddMap<T>`. For now, you can ignore the `Index()` call, we'll discuss this in length on the next chapter. 

But this is discussing the _structure_ of the index in Listing 8.6, what is it that it is _doing_? This index is going to operate on the Companies, Employees and Suppliers collections, and it is going to index a single field, `Name` in all of them. Note that in the case of the employees, we are indexing a computed field, and in the other two, we are indexing a nested one.

What is important is that in all three cases, we are actually outputing the same _shape_ to the index. Let us see what we can do with this index, shall we. You can create it using the following code:

	new People_Search().Execute(documentStore);

Then go to the studio, to the Indexes tab and clik on the `People/Search` index^[Remember, People_Search on the client side is translated to People/Search on the server side for index and transformer names.]. You are now in the query page for the `People/Search` index, enter `Name: Michael` in the query text and then press the query button. The result is shown in Figure 8.1.

![Results of querying the People/Search index for "Michael"](.\Ch08\Figure01.png)

Look at the results. We have three documents here: `companies/68`, `employees/6` and `suppliers/17`, from three different collections. All of them matches our query. So now that we saw what was going on, it is time to understand what is actually _happening_.

A multi map index is just like any other index, the only difference is that it will cover multiple collections. It goes through the same exact stages. It accept documents to be indexes, but instead of having just a single map function, it has several. Usually, one for each collection that you want to include.

The nearest parallel you are probably familiar with is the notion of a union in a relational database. But unlike such a union, we aren't doing this during query time, we are merging the indexing results from multiple collections during index, and into the same index. That allows you to do some pretty cool stuff (which we'll explore more therally after we learn about map/reduce), but even at this point, I'm sure that you can see how useful such an ability can be.

If you'll take another look at Figure 8.1 you'll see that we get three documents from three different collections. How are we going to work with that on the client side? 

### Multi map indexes from the client perspective

RavenDB itself doesn't care about schema or types or any such thing, but because we are working with a strongly typed language, we need to be to get the result of queries on the `People/Search` index and do something with it. We can just issue a weakly typed query, such as:

	List<object> results = session.Advanced.DocumentQuery<object, People_Search>()
	    .WhereEquals("Name", "Michael")
	    .ToList(); 

We can then run through the results and cast them to the right types. That _works_, but it is ugly and quite uncomfortable. We can do better, by asking RavenDB to give us a common shape back. That can be if the types share a common ancestor, but a lot of the time, that isn't the case. We want to just get data from several unrelated documents and do something with it. Typically, show it to the user.

The easiest way to do that is to use projections.

## Projections

Projections are a way to collect several fields from document, instead of working with the whole document. In the case we have now, we already know the shape of the data that we want to deal with. It is the same common shape already defined in the index. The multi map index enforce that all map functions will have the same output, and we can use that when the time comes to query the index. In the case of the `People/Search` index, that means that we are going to be showing a list of names, the type of the document and its id. Listing 8.7 shows the changes required to make this work.

```{caption="{Multi map index that allows projections}" .cs}
public class People_Search : 
	AbstractMultiMapIndexCreationTask<People_Search.Result>
{
	public class Result
	{
		public string Type { get; set; }
		public string Id { get; set; }
		public string Name { get; set; }
	}

	public People_Search()
	{
		AddMap<Company>(companies =>
			from company in companies
			select new
			{
				company.Id,
				company.Contact.Name,
				Type = "Company"
			});

		AddMap<Employee>(employees =>
			from employee in employees
			select new
			{
				employee.Id,
				Name = employee.FirstName + " " + employee.LastName,
				Type = "Employee"
			});

		AddMap<Supplier>(suppliers =>
			from supplier in suppliers
			select new
			{
				supplier.Id,
				supplier.Contact.Name,
				Type = "Supplier"
			});

		Index("Name", FieldIndexing.Analyzed);

		Store(x => x.Id, FieldStorage.Yes);
		Store(x => x.Name, FieldStorage.Yes);
		Store(x => x.Type, FieldStorage.Yes);
	}
}
```

The first thing to note is that we now define an inner class called Result, and reference that as the generic argument. The generic argument doesn't have to be an inner class, but that is a common convention, because it ties the index and its exepcted result together. We have seen used before for queries, but now we are going to use this for getting the relevant data:

	var results = session.Query<People_Search.Result, People_Search>()
		.Where(x=>x.Name == "Michael")
		.ProjectFromIndexFieldsInto<People_Search.Result>()
		.ToList();

What is going on in this piece of code? First, we tell the RavenDB Linq Provider that we'll be querying the `People/Search` index, and that we'll be using the `People_Search.Result` class as the query model. Then we actually specify the query, and finally, we ask RavenDB to project the result from the index. What does this mean?

Look at the last lines of Listing 8.7, we have a few `Store()` calls there. Usually, the index doesn't bother to keep around any data beyond what it needs to actually answer a query. But because we told it to store the information, it won't only index the data, but also allow us to retreive the information directly from the index.

Usually queries in RavenDB have the following workflow:

* Execute the query against the index
* Gather all the matching document ids
* Load the documents from the document store
* Return documents to client

When we use projections, the workflow is different, instead of getting just the document ids from the index, we'll also get the projected fields. That is why we have to store them in the index. That means that we'll query the index, load the results directly from it, and immediately return to the client. 

And in this case, we'll return a list of (Id, Name, Type) to the client, and the client can show it to the user, who will perform any additional actions on them.

> **What happens if we project a non stored field?**
>
> If you project on a field that isn't stored, RavenDB will load the document from the document store, and then get the field from the document directly.
> You get the correct result, but you incur the cost of actually loading the document from disk, although it won't be sent over the network. 
> For small documents, that is hardly anything major, but for large documents, that might be something that you want to pay attention to.

Projections aren't limited to multi map indexes, you can use them in any index, and they are frequently quite useful. They also go hand in hand with transformers, which also allows you to limit the amount of data that you get from the server. A transformer running on an index will first try to find a stored field, and only if it can't find the stored field will it load the document.

Because projections are usually based on the data in the index, they are subject to the same staleness consideration. If you load the data directly from the document (whatever by loading the document itself or by projecting from the document) you are ensured that you'll always have the latest version at the time of the query. If you are projecting data stored in the index, it is possible that the data on the document has changed since then.

You don't have to store all the fields in the index, you usually store just the fields that you care to project out. Linq queries such as the following one are also using projections under the cover:

	from order in session.Query<Order>()
	select new
	{
	  order.Company,
	  order.OrderedAt,
	}

This query will project the `Company` and `OrderedAt` fields, such queries are the reason why we fallback to the document if the index doesn't already store those fields.

## Load Document 

Uncle Ben said that with great power comes great responsability. My version of that is that great features can also produce the most headache. The Load Document feature is a really awesome one, but it is also something that should be used carefully. It isn't meant to be the hammer that you'll use to beat every problem into submission. Scared yet?

I do admit that this is quite an introduction for a feature that we haven't even discussed. But we have had a lot of problems with users tripping themselves over this feature, and most this has been because they came to it from a relational mindset. So I would ask that you'll read this section to understand the _technical_ nature of this feature, but refrain from using it until you have read the [Part III - Modeling](#modeling) and can understand the proper way to design a document based modeling with RavenDB.

With this ominous introduction out of the way, let us see what this feature is all about. And it is a really cool feature. Load Document allows you to load another document during index, and use its data in your index. Let us take a simple example, we want to search for product by its category. You can see how product store the category information in Figure 8.2.

![The products in the Northwind database](.\Ch08\Figure02.png)

This means that it is trivially easy to run a query asking: "Give me all the products in the categories/1 category". However, what would happen if we wanted to ask: "Give me all the products in the Beverages category"? Well, _that_ is a much harder query to answer. In fact, using what we have done so far, we _can't_ answer it.

What we'll have to do is to first make a query to find the category ids of all the categories whose name is Beverages, then query the products in those categories. That works, and it is in fact usually recommended, but Load Document allows us to have another option, as Listing 8.8 shows.

```{caption="{Using LoadDocument in an index}" .cs}
public class Products_Search : AbstractIndexCreationTask<Product,Products_Search .Result>
{
	public class Result
	{
		public string CategoryName { get; set; }
	}

	public Products_Search()
	{
		Map = products =>
			from product in products
			select new
			{
				CategoryName = LoadDocument<Category>(product.Category).Name
			};
	}
}
```

What is going on in Listing 8.8? We are calling `LoadDocument<Category>(product.Category)` in the map, loading the relevant category and indexing its name. That means that we can now query for the products in the Beverages category using the following code:

	var results = session.Query<Products_Search.Result, Products_Search>()
		.Where(p => p.CategoryName == "Beverages")
		.OfType<Product>()
		.ToList();

As we discussed previously in this chapter, because we have a different model for the shape of the index and the shape of the result, we start the query with the `Products_Search.Result` and then use `OfType<Product>` to change the Linq result to the appropriate returned type.

Now, what is actually going on here? Let us consider the case of the `products/70` document, being indexed by the `Products/Search` index. During index, we call the `LoadDocument` method, which will then fetch the `categories/1` and index the category name in the index for the `products/70` document. Now we can search for "CategoryName: Beverages", and get (among others) the `products/70' document.

So far, so good, and a really useful feature. But let us get down to the nitty gritty details. 
Because this happens during indexing, what happens if the relevant category is null, or if it it has a value in that field is of a non existant document id? 
Like any other null handling in RavenDB handling, this is handled for you, and you don't need to write null checks or guard against that.

A more interesting problem happens when we deal with changes. Given the previously mentioned 'products/70' and its associated 'categories/1'. The index entry for the 'products/70' looked like the following:

	{ 'CategoryName': 'Beverages', '__document_id': 'products/70'}

What happens when we are update the 'categories/1' document? For example, to change the name from Beverages to Drinks? Documents are only re-indexed when they are changed. So we would expect that since 'products/70' didn't change, we won't have this index entry update, and it will reflect the state of the data at the time of the product's indexing.

RavenDB is smart enough to recognize that this would turn this feature into a curiosity, nothing more. Because of that, RavenDB create an internal association between the two documents. You can think about it as an internal table that associates 'products/70' with 'categories/1'. Whenever we put a document, we check those associations, and we _touch_ all the referencing documents, which will force their re-indexing.

> **Who touched my documents?**
>
> Touching a document usually happens whenever we detect that a document that has been referenced by this document during index has changed, 
> so the document need to be reindexed (to pick up the new values from the referenced document). Touching a document involves updating its etag
> value, which will force it to be re-indexed.

## The dark side of Load Document

So far, I gave a grave warning, and then proceeded to show how cool it is. Why the pre-empative strike against this feature?

The problem with Load Document is that is allows users to keep a relational model when they work with RavenDB, and use Load Document to get away with it when they need to do something that is hard to do with RavenDB natively. That wouldn't be so bad, if Load Document didn't have several important costs associated with it.

### The commonly referenced & updated document 

In one memorable case, a customer was complaining about very high CPU usage and constant work. Their usage didn't match their load. After investigating, we realize that they had a very large collection (98%+ of their documents) which had an index similar to this:

	from order in docs.Orders
	select new
	{
		// lot of other stuff
		Status = LoadDocument("config/global").Status[order.StatusId]
	}

That means that for all the order documents in the database, we had an association to the `config/global` document. That is bad enough, but this `config/global` document was also update every 15 minutes by a background task. I'm sure that you can figure out where that led.

Every 15 minutes, the `config/global` document would be updated, forcing us to touch all of the orders documents which referenced it. That was expensive enough, but it gets worse. Because we touched all those documents, we now need to index them. Effectively, they managed to create a denial of service attack against RavenDB. Things actually worked for them, to the point where this was a "of concern" issue rather than a "sky is falling" issue because RavenDB was able to adapt to the load by shifting resources around and still serve requests and process indexes.

That is a patalogical case, admitedly, but it does show a problem. Basically, the cost of updating a document is directly proportional to how many documents are referecing it. And we had cases where the number of documents referencing a document was big enough so updating it became practically impossible.

> **Recommendation: Use LoadDocument carefully**
>
> For the most part, properly modeling your domain saves you from the need to use Load Document. But when you use it, you need to consider the implications.
> In particular, make sure that the references you are creating aren't going to cause a single document to be referenced by a very large number of documents. 
> Usually, that indicate a weakness in your domain, which should be addressed. 

### Load Document costs and heuristics

The Load Document associations are kept on a per index basis, so deleting or updating an index definition is also directly proportional to the number of association in the index. Usually, this doesn't matter, since index definition deletion or updates are async, but that is something to be aware of for the I/O costs involved.

If that isn't enough for you, Load Document _completely_ messes up all heuristics RavenDB is using to optimize indexing. Because the Load Document is opaque for RavenDB, whenever you call it, we have to load the document from disk. RavenDB goes to great lengths to avoid having to do that on a syncronous code path, but Load Document doesn't give us another option, we are given a document id and we need to load it. There are things that we can do (caching of loaded documents in the same batch, for example), but for the most part, Load Document force us to stop indexing, load the document, and resume indexing.

If you have a large number of Load Document calls, that can signficantly slow down your indexing time. This usually doesn't show up during normal operation (where the number of documents indexed is relatively small), but it is an issue if you are updating an index definition and need to index a large number of documents (and call Load Document a large number of times).

The call of Load Document is a tempting one, "Come to Dark Side, we have cookies". And it _is_ a very powerful feature, but it is something that you should be using after carefully understanding the implications of that.

The most common usage of Load Document unfortunately is when users model documents in RavenDB in the same manner that they did when using a relational database, failing to understand that a very different database engine require a different approach. We'll discuss this in great length in the modeling part of the book.

## Queries

We have gone over a lot of the details in static indexes, and we are almost done with this topic. Before we go on to talk about full text search and map/reduce, I wanted to go over potential queries options in RavenDB. This isn't meant to be an exhaustive list (see the [documentation](http://ravendb.net/docs) for that), but it should give you a good idea about the kind of querying capabilities that RavenDB has.

A lot of that is probably obvious, and you can skim through the rest of this section without losing much.

### Equality and comparisons

Probably the easiest to explain is the notion of equality. RavenDB support equality in queries using the following:

	var results = from emp in session.Query<Employee>()
				  where emp.FirstName == "Steven"
				  select emp;

By default, RavenDB compare value as strings, so when we do something like this: `Where(x=>x.IsActive)` we are actually sending the following query to the server: `IsActive: true`. You don't need to worry about the cost of string equality checks. We aren't _actually_ comparing the values. What we do is scan through a sorted index to get the relevant details out. Unless you specified differently (discussed in the next chapter), RavenDB will use case insensitive comparison to do this match. 

This is important because we had questions in the mailing list where people defined a comparison operator or a overrode `Equals` and were surprised when RavenDB didn't pick up on that. Queries are always executed on the server, and they don't involve any code written by the user.

Comparisons (greater than, less than or greater than or equals, less than or equals) are also pretty obvious:

	var results = 
		from order in session.Query<Order>()
		where order.Freight >= 25
		select order;

Those, too, are using the index rather than compare all the values. Note that we have implemented special behavior for numerics, so we can compare them without incuring 3 is greater than 10 issues when doing lexical comparisons of numbers. 

### Query clasues

Queries aren't limited to single property equality or comparison. You can create complex queries using OR and AND. Those behave as you expect them to, as the following query demonstrates:

	var results = 
		from order in session.Query<Order>()
		where (order.Freight > 25 && order.Freight < 50) || order.ShippedAt == null
		select order;

This linq statement is translated to the following query:

	Freight_Range:{Dx25 TO Dx50} OR ShippedAt:[[NULL_VALUE]]

You can see that we query on the Freight_Range field, this is an automatically generated field, that holds the numeric value of the Freight field in a way that allow su to do efficent range seraches. The `order.Freight > 25 && order.Freight < 50` was translated to an efficent between operation: `Freight_Range:{Dx25 TO Dx50}` and the OR between the two clauses is there as well.

The null comparison is a bit interesting, since we need to compare to _something_ in the index, we use the value of [[NULL_VALUE]] as a sentinal null value.

You can read more about how this work in the documentation about the [full query syntax](http://ravendb.net/docs/article-page/3.0/Csharp/indexes/querying/full-query-syntax) that RavenDB uses.

### Prefix and postfix searches

RavenDB also supports prefix searches (StartsWith), this is done by the following linq statement:

	var results = 
		from emp in session.Query<Employee>()
		where emp.FirstName.StartsWith("Marg")
		select emp;

This is translated to the following query: `FirstName: Marg*`. The same can be done in reverse, by using EndsWith. However, that is no advisable. Using prefix query, we can make a good use of our indexes to efficently answer the query. The same is not true for EndsWith, that requires us to scan the entire index. A better alternative if you need to query using EndsWith is to create an index with the reversed value and use the much more efficent StartsWith on that.

in, contains, any
[[unanalyzed]]

## Summary